
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>borsar.cluster &#8212; borsar 0.1dev documentation</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/style.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          borsar</a>
        <span class="navbar-text navbar-version pull-left"><b>0.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../auto_examples/index.html">Examples</a></li>
                <li><a href="../../api.html">API</a></li>
                <li><a href="https://github.com/mmagnuski/borsar">GitHub</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container content-container">
  
  <h1>Source code for borsar.cluster</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">sparse</span>

<span class="kn">from</span> <span class="nn">borsar.utils</span> <span class="k">import</span> <span class="n">find_range</span>
<span class="kn">from</span> <span class="nn">borsar.stats</span> <span class="k">import</span> <span class="n">compute_regression_t</span><span class="p">,</span> <span class="n">format_pvalue</span>
<span class="kn">from</span> <span class="nn">borsar._viz3d</span> <span class="k">import</span> <span class="n">plot_cluster_src</span>
<span class="kn">from</span> <span class="nn">borsar.clusterutils</span> <span class="k">import</span> <span class="p">(</span><span class="n">_check_stc</span><span class="p">,</span> <span class="n">_label_from_cluster</span><span class="p">,</span> <span class="n">_get_clim</span><span class="p">,</span>
                                 <span class="n">_prepare_cluster_description</span><span class="p">,</span>
                                 <span class="n">_aggregate_cluster</span><span class="p">,</span> <span class="n">_get_units</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">borsar.channels</span> <span class="k">import</span> <span class="n">find_channels</span>


<span class="k">def</span> <span class="nf">construct_adjacency_matrix</span><span class="p">(</span><span class="n">neighbours</span><span class="p">,</span> <span class="n">ch_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">as_sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Construct adjacency matrix out of neighbours structure (fieldtrip format).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># checks for ch_names</span>
    <span class="k">if</span> <span class="n">ch_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ch_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="s1">&#39;ch_names must be a list.&#39;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="n">ch_names</span><span class="p">)),</span> \
            <span class="s1">&#39;ch_names must be a list of strings&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ch_names</span> <span class="o">=</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="n">n_channels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)</span>
    <span class="n">conn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_channels</span><span class="p">,</span> <span class="n">n_channels</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ch_names</span><span class="p">):</span>
        <span class="n">ngb_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">chan</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># safty checks:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ngb_ind</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s1">&#39;channel </span><span class="si">{}</span><span class="s1"> was not found in neighbours.&#39;</span>
                              <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chan</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ngb_ind</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ngb_ind</span> <span class="o">=</span> <span class="n">ngb_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;found more than one neighbours entry for &#39;</span>
                             <span class="s1">&#39;channel name </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chan</span><span class="p">))</span>

        <span class="c1"># find connections and fill up adjacency matrix</span>
        <span class="n">connections</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">neighbours</span><span class="p">[</span><span class="s1">&#39;neighblabel&#39;</span><span class="p">]</span>
                       <span class="p">[</span><span class="n">ngb_ind</span><span class="p">]</span> <span class="k">if</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">ch_names</span><span class="p">]</span>
        <span class="n">chan_ind</span> <span class="o">=</span> <span class="n">ch_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span>
        <span class="n">conn</span><span class="p">[</span><span class="n">chan_ind</span><span class="p">,</span> <span class="n">connections</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">as_sparse</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">conn</span>


<span class="k">def</span> <span class="nf">cluster_based_regression</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">preds</span><span class="p">,</span> <span class="n">adjacency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_permutations</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                             <span class="n">stat_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha_threshold</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
                             <span class="n">progressbar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_distribution</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;TODO: add DOCs!&#39;&#39;&#39;</span>
    <span class="c1"># data has to have observations as 1st dim and channels/vert as last dim</span>
    <span class="kn">from</span> <span class="nn">mne.stats.cluster_level</span> <span class="k">import</span> <span class="p">(</span><span class="n">_setup_connectivity</span><span class="p">,</span> <span class="n">_find_clusters</span><span class="p">,</span>
                                         <span class="n">_cluster_indices_to_mask</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">preds</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="n">preds</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">preds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span>
        <span class="s1">&#39;`preds` must be 1d array or 2d array where the second dimension is&#39;</span>
        <span class="s1">&#39; one (only one predictor).&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">stat_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">t</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="c1"># in future: preds.shape[1]</span>
        <span class="n">stat_threshold</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha_threshold</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>

    <span class="c1"># TODO - move progressbar code from DiamSar</span>
    <span class="c1">#      - then support tqdm pbar as input</span>
    <span class="c1">#      - use autonotebook</span>
    <span class="k">if</span> <span class="n">progressbar</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">tqdm</span> <span class="k">import</span> <span class="n">tqdm</span>
        <span class="n">pbar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="n">n_permutations</span><span class="p">)</span>

    <span class="n">n_obs</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">adjacency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">adjacency</span> <span class="o">=</span> <span class="n">_setup_connectivity</span><span class="p">(</span><span class="n">adjacency</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span>
                                        <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">pos_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_permutations</span><span class="p">)</span>
    <span class="n">neg_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_permutations</span><span class="p">)</span>
    <span class="n">perm_preds</span> <span class="o">=</span> <span class="n">preds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># regression on non-permuted data</span>
    <span class="n">t_values</span> <span class="o">=</span> <span class="n">compute_regression_t</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">preds</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">cluster_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="k">if</span> <span class="n">adjacency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="k">else</span> <span class="n">t_values</span><span class="p">)</span>
    <span class="n">clusters</span><span class="p">,</span> <span class="n">cluster_stats</span> <span class="o">=</span> <span class="n">_find_clusters</span><span class="p">(</span>
        <span class="n">cluster_data</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">stat_threshold</span><span class="p">,</span> <span class="n">tail</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">adjacency</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">adjacency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">_cluster_indices_to_mask</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="n">clusters</span> <span class="o">=</span> <span class="p">[</span><span class="n">clst</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="k">for</span> <span class="n">clst</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">clusters</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No clusters found, permutations are not performed.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t_values</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">cluster_stats</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Found </span><span class="si">{}</span><span class="s1"> clusters, computing permutations.&#39;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)))</span>

    <span class="c1"># compute permutations</span>
    <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_permutations</span><span class="p">):</span>
        <span class="c1"># permute predictors</span>
        <span class="n">perm_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">n_obs</span><span class="p">)</span>
        <span class="n">this_perm</span> <span class="o">=</span> <span class="n">perm_preds</span><span class="p">[</span><span class="n">perm_inds</span><span class="p">]</span>
        <span class="n">perm_tvals</span> <span class="o">=</span> <span class="n">compute_regression_t</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">this_perm</span><span class="p">)</span>

        <span class="c1"># cluster</span>
        <span class="n">cluster_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">perm_tvals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="k">if</span> <span class="n">adjacency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="k">else</span> <span class="n">perm_tvals</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">perm_cluster_stats</span> <span class="o">=</span> <span class="n">_find_clusters</span><span class="p">(</span>
            <span class="n">cluster_data</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">stat_threshold</span><span class="p">,</span> <span class="n">tail</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">connectivity</span><span class="o">=</span><span class="n">adjacency</span><span class="p">)</span>

        <span class="c1"># if any clusters were found - add max statistic</span>
        <span class="k">if</span> <span class="n">perm_cluster_stats</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">max_val</span> <span class="o">=</span> <span class="n">perm_cluster_stats</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">min_val</span> <span class="o">=</span> <span class="n">perm_cluster_stats</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">max_val</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">pos_dist</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_val</span>
            <span class="k">if</span> <span class="n">min_val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">neg_dist</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_val</span>

        <span class="k">if</span> <span class="n">progressbar</span><span class="p">:</span>
            <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># compute permutation probability</span>
    <span class="n">cluster_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">pos_dist</span> <span class="o">&gt;</span> <span class="n">cluster_stat</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="k">if</span> <span class="n">cluster_stat</span> <span class="o">&gt;</span> <span class="mi">0</span>
                          <span class="k">else</span> <span class="p">(</span><span class="n">neg_dist</span> <span class="o">&lt;</span> <span class="n">cluster_stat</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                          <span class="k">for</span> <span class="n">cluster_stat</span> <span class="ow">in</span> <span class="n">cluster_stats</span><span class="p">])</span>
    <span class="n">cluster_p</span> <span class="o">*=</span> <span class="mi">2</span> <span class="c1"># because we use two-tail</span>
    <span class="n">cluster_p</span><span class="p">[</span><span class="n">cluster_p</span> <span class="o">&gt;</span> <span class="mf">1.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span> <span class="c1"># probability has to be &lt;= 1.</span>

    <span class="c1"># sort clusters by p value</span>
    <span class="n">cluster_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">cluster_p</span><span class="p">)</span>
    <span class="n">cluster_p</span> <span class="o">=</span> <span class="n">cluster_p</span><span class="p">[</span><span class="n">cluster_order</span><span class="p">]</span>
    <span class="n">clusters</span> <span class="o">=</span> <span class="p">[</span><span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cluster_order</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">return_distribution</span><span class="p">:</span>
        <span class="n">distribution</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">pos_dist</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="n">neg_dist</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t_values</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">cluster_p</span><span class="p">,</span> <span class="n">distribution</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">t_values</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">cluster_p</span>


<div class="viewcode-block" id="read_cluster"><a class="viewcode-back" href="../../generated/borsar.cluster.read_cluster.html#borsar.cluster.read_cluster">[docs]</a><span class="k">def</span> <span class="nf">read_cluster</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">subjects_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Read standard Clusters .hdf5 file and return Clusters object.</span>
<span class="sd">    You need to pass correct subjects_dir and src to `read_cluster` if your</span>
<span class="sd">    results are in source space or correct info if your results are in channel</span>
<span class="sd">    space.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">        File path for the file to read.</span>
<span class="sd">    subjects_dir : str, optional</span>
<span class="sd">        Path to Freesurfer subjects directory.</span>
<span class="sd">    src : mne.SourceSpaces, optional</span>
<span class="sd">        Source space that the results are reprseneted in.</span>
<span class="sd">    info : mne.Info, optional</span>
<span class="sd">        Channel space that the results are respresented in.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    clst : Clusters</span>
<span class="sd">        Cluster results read from file.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">mne.externals</span> <span class="k">import</span> <span class="n">h5io</span>
    <span class="c1"># subjects_dir = mne.utils.get_subjects_dir(subjects_dir, raise_error=True)</span>
    <span class="n">data_dict</span> <span class="o">=</span> <span class="n">h5io</span><span class="o">.</span><span class="n">read_hdf5</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="n">clst</span> <span class="o">=</span> <span class="n">Clusters</span><span class="p">(</span>
        <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;clusters&#39;</span><span class="p">],</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;pvals&#39;</span><span class="p">],</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;stat&#39;</span><span class="p">],</span>
        <span class="n">dimnames</span><span class="o">=</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;dimnames&#39;</span><span class="p">],</span> <span class="n">dimcoords</span><span class="o">=</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;dimcoords&#39;</span><span class="p">],</span>
        <span class="n">subject</span><span class="o">=</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;subject&#39;</span><span class="p">],</span> <span class="n">subjects_dir</span><span class="o">=</span><span class="n">subjects_dir</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">,</span>
        <span class="n">src</span><span class="o">=</span><span class="n">src</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">clst</span></div>


<span class="c1"># TODO - consider empty lists/arrays instead of None when no clusters...</span>
<div class="viewcode-block" id="Clusters"><a class="viewcode-back" href="../../generated/borsar.cluster.Clusters.html#borsar.cluster.Clusters">[docs]</a><span class="k">class</span> <span class="nc">Clusters</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Container for results of cluster-based tests.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    clusters : list of boolean ndarrays | boolean ndarray</span>
<span class="sd">        List of boolean masks - one per cluster. The masks should match the</span>
<span class="sd">        dimensions of the `stat` ndarray. Each mask descirbes which elements</span>
<span class="sd">        are members of given cluster. Alternatively - one boolean array where</span>
<span class="sd">        first dimension corresponds to consevutive clusters. When no clusters</span>
<span class="sd">        were found this can be an empty numpy array, an empty list or None.</span>
<span class="sd">    pvals : list or array of float</span>
<span class="sd">        List/array of p values corresponding to consecutive clusters in</span>
<span class="sd">        `clusters`. If no clusters were found this can be an empty numpy array,</span>
<span class="sd">        an empty list or None.</span>
<span class="sd">    stat : ndarray</span>
<span class="sd">        Statistical map of the analysis. Usual dimensions are: space,</span>
<span class="sd">        space x time, space x frequencies, space x frequencies x</span>
<span class="sd">        time where space corresponds to channels or vertices (in the source</span>
<span class="sd">        space).</span>
<span class="sd">    dimnames : list of str, optional</span>
<span class="sd">        List of dimension names. For example `[&#39;chan&#39;, &#39;freq&#39;]` or `[&#39;vert&#39;,</span>
<span class="sd">        &#39;time&#39;]`. The length of `dimnames` has to mach `stat.ndim`.</span>
<span class="sd">        If &#39;chan&#39; dimname is given, you also need to provide `mne.Info`</span>
<span class="sd">        corresponding to the channels via info keyword argument.</span>
<span class="sd">        If &#39;vert&#39; dimname is given, you also need to provide forward, subject</span>
<span class="sd">        and subjects_dir via respective keyword arguments.</span>
<span class="sd">    dimcoords : list of arrays, optional</span>
<span class="sd">        List of arrays, where each array contains coordinates (labels) for</span>
<span class="sd">        consecutive elements in corresponding dimension. For example if your</span>
<span class="sd">        `stat` represents channels by frequencies then a) `dimcoords[0]` should</span>
<span class="sd">        have length of `stat.shape[0]` and its consecutive elements should</span>
<span class="sd">        represent channel names while b) `dimcoords[1]` should have length of</span>
<span class="sd">        `stat.shape[1]` and its consecutive elements should represent centers</span>
<span class="sd">        of frequency bins (in Hz).</span>
<span class="sd">    info : mne.Info, optional</span>
<span class="sd">        When using channel space (&#39;chan&#39; is one of the dimnames) you need to</span>
<span class="sd">        provide information about channel position in mne.Info file (for</span>
<span class="sd">        example `epochs.info`).</span>
<span class="sd">    src : mne.SourceSpaces, optional</span>
<span class="sd">        When using source space (&#39;vert&#39; is one of the dimnames) you need to</span>
<span class="sd">        pass mne.SourceSpaces</span>
<span class="sd">    subject : str, optional</span>
<span class="sd">        When using source space (&#39;vert&#39; is one of the dimnames) you need to</span>
<span class="sd">        pass a subject name (name of the freesurfer directory with file for</span>
<span class="sd">        given subject).</span>
<span class="sd">    subjects_dir : str, optional</span>
<span class="sd">        When using source space (&#39;vert&#39; is one of the dimnames) you need to</span>
<span class="sd">        pass a Freesurfer subjects directory (path to the folder contraining</span>
<span class="sd">        subjects as subfolders).</span>
<span class="sd">    description : str | dict, optional</span>
<span class="sd">        Optional description of the Clusters - for example analysis parameters</span>
<span class="sd">        and some other additional details.</span>
<span class="sd">    sort_pvals : bool</span>
<span class="sd">        Whether to sort clusters by their p-value (ascending). Default: True.</span>
<span class="sd">    &#39;&#39;&#39;</span>
<div class="viewcode-block" id="Clusters.__init__"><a class="viewcode-back" href="../../generated/borsar.cluster.Clusters.html#borsar.cluster.Clusters.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">pvals</span><span class="p">,</span> <span class="n">stat</span><span class="p">,</span> <span class="n">dimnames</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dimcoords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">subject</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">subjects_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">description</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort_pvals</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">safety_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">safety_checks</span><span class="p">:</span>
            <span class="c1"># basic safety checks</span>
            <span class="n">clusters</span><span class="p">,</span> <span class="n">pvals</span> <span class="o">=</span> <span class="n">_clusters_safety_checks</span><span class="p">(</span>
                <span class="n">clusters</span><span class="p">,</span> <span class="n">pvals</span><span class="p">,</span> <span class="n">stat</span><span class="p">,</span> <span class="n">dimnames</span><span class="p">,</span> <span class="n">dimcoords</span><span class="p">,</span> <span class="n">description</span><span class="p">)</span>

            <span class="c1"># check channel or source space</span>
            <span class="n">_clusters_chan_vert_checks</span><span class="p">(</span><span class="n">dimnames</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">subject</span><span class="p">,</span>
                                       <span class="n">subjects_dir</span><span class="p">)</span>

            <span class="c1"># check polarity of clusters</span>
            <span class="n">polarity</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;neg&#39;</span><span class="p">,</span> <span class="s1">&#39;pos&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster_polarity</span> <span class="o">=</span> <span class="p">([</span><span class="n">polarity</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">stat</span><span class="p">[</span><span class="n">cl</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)]</span>
                                      <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">]</span> <span class="k">if</span> <span class="n">pvals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                                      <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pvals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pvals</span><span class="p">)</span>

            <span class="c1"># sort by p values if necessary</span>
            <span class="k">if</span> <span class="n">sort_pvals</span><span class="p">:</span>
                <span class="n">psort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">pvals</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">psort</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">pvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">clusters</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="n">psort</span><span class="p">]</span>
                    <span class="n">pvals</span> <span class="o">=</span> <span class="n">pvals</span><span class="p">[</span><span class="n">psort</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cluster_polarity</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_polarity</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                                             <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">psort</span><span class="p">]</span>

        <span class="c1"># create attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subjects_dir</span> <span class="o">=</span> <span class="n">subjects_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">description</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimcoords</span> <span class="o">=</span> <span class="n">dimcoords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimnames</span> <span class="o">=</span> <span class="n">dimnames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subject</span> <span class="o">=</span> <span class="n">subject</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pvals</span> <span class="o">=</span> <span class="n">pvals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stat</span> <span class="o">=</span> <span class="n">stat</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src</span> <span class="o">=</span> <span class="n">src</span>

        <span class="c1"># FIXME: find better way for this (maybe during safety checks earlier)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">safety_checks</span><span class="p">:</span>
            <span class="n">_ensure_correct_info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


    <span class="c1"># - [ ] add warning if all clusters removed</span>
    <span class="c1"># - [ ] consider select to _not_ work inplace</span>
    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">percentage_in</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_points_in</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">n_points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Select clusters by p value threshold or its location in the data space.</span>

<span class="sd">        Note that this method works in-place.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        p_threshold : None | float</span>
<span class="sd">            Threshold for cluster-level p value. Only clusters associated with</span>
<span class="sd">            a p value lower than this threshold are selected. Defaults to None</span>
<span class="sd">            which does not select clusters by p value.</span>
<span class="sd">        percentage_in : None | float</span>
<span class="sd">            Select clusters by percentage participation in range of the data</span>
<span class="sd">            space specified in **kwargs. For example</span>
<span class="sd">            `clst.select(percentage_in=0.15, freq=[3, 7])` selects only those</span>
<span class="sd">            clusters that have at least 15% of their mass in 3 - 7 Hz frequency</span>
<span class="sd">            range. Defaults to None which does not select clusters by their</span>
<span class="sd">            participation in data space.</span>
<span class="sd">        n_points_in : None | int</span>
<span class="sd">            Select clusters by number of their minimum number of data points</span>
<span class="sd">            that lie in the range of the data specified in **kwargs. For</span>
<span class="sd">            example `clst.select(n_points_in=25, time=[0.2, 0.35])` selects</span>
<span class="sd">            only those clusters that contain at least 25 points within</span>
<span class="sd">            0.2 - 0.35 s time range. Defaults to None which does not select</span>
<span class="sd">            clusters by number of points participating in data space.</span>
<span class="sd">        n_points : None | int</span>
<span class="sd">            Select clusters by their minimum number of data points. For example</span>
<span class="sd">            `clst.select(n_points=5)` selects only those clusters that have at</span>
<span class="sd">            least 5 data points. Default to None which does not perform the</span>
<span class="sd">            selection.</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        clst : borsar.cluster.Clusters</span>
<span class="sd">            Selected clusters.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># select clusters by p value threshold</span>
        <span class="k">if</span> <span class="n">p_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvals</span> <span class="o">&lt;</span> <span class="n">p_threshold</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="n">_cluster_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sel</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n_points_in</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># kwargs check should be in separate function</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">_check_dimnames_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">dim_idx</span> <span class="o">=</span> <span class="n">_index_from_dim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimnames</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimcoords</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="n">dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stat</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">clst_idx</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="n">dim_idx</span>
            <span class="n">cluster_sel_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">clst_idx</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>

            <span class="n">sel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n_points_in</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sel</span> <span class="o">=</span> <span class="n">cluster_sel_size</span> <span class="o">&gt;=</span> <span class="n">n_points_in</span>
            <span class="k">if</span> <span class="n">percentage_in</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cluster_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
                <span class="n">sel</span> <span class="o">=</span> <span class="p">((</span><span class="n">cluster_sel_size</span> <span class="o">/</span> <span class="n">cluster_size</span> <span class="o">&gt;=</span> <span class="n">percentage_in</span><span class="p">)</span>
                       <span class="o">&amp;</span> <span class="n">sel</span><span class="p">)</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="n">_cluster_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sel</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="c1"># TODO: add deepcopy arg (`deep=False` by default)?</span>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Copy the Clusters object.</span>

<span class="sd">        The lists/arrays are not copied however. The SourceSpaces are always</span>
<span class="sd">        copied because they often change when plotting.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        clst : Clusters</span>
<span class="sd">            Copied Clusters object.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">clst</span> <span class="o">=</span> <span class="n">Clusters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimnames</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dimcoords</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">,</span>
                        <span class="n">subject</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">subject</span><span class="p">,</span> <span class="n">subjects_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">subjects_dir</span><span class="p">,</span>
                        <span class="n">description</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
                        <span class="n">safety_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort_pvals</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">clst</span><span class="o">.</span><span class="n">stc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stc</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">stc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">clst</span><span class="o">.</span><span class="n">cluster_polarity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_polarity</span>
        <span class="k">return</span> <span class="n">clst</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Return number of clusters in Clusters.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Initialize iteration.&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get next cluster in iteration. Allows to do things like:</span>
<span class="sd">        &gt;&gt;&gt; for clst in clusters:</span>
<span class="sd">        &gt;&gt;&gt;     clst.plot()</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="n">clst</span> <span class="o">=</span> <span class="n">Clusters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_current</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">pvals</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">_current</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">stat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimnames</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dimcoords</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">,</span>
                        <span class="n">subject</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">subject</span><span class="p">,</span> <span class="n">subjects_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">subjects_dir</span><span class="p">,</span>
                        <span class="n">description</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
                        <span class="n">safety_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort_pvals</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">clst</span><span class="o">.</span><span class="n">stc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stc</span> <span class="c1"># or .copy()?</span>
        <span class="n">clst</span><span class="o">.</span><span class="n">cluster_polarity</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_polarity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_current</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">clst</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Save Clusters to hdf5 file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : str</span>
<span class="sd">            Path to save the file in.</span>
<span class="sd">        description : str, dict</span>
<span class="sd">            Additional description added when saving. When passed overrides</span>
<span class="sd">            the description parameter of Clusters.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">mne.externals</span> <span class="k">import</span> <span class="n">h5io</span>

        <span class="k">if</span> <span class="n">description</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">description</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_check_description</span><span class="p">(</span><span class="n">description</span><span class="p">)</span>

        <span class="n">data_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;clusters&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">,</span> <span class="s1">&#39;pvals&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvals</span><span class="p">,</span>
                     <span class="s1">&#39;stat&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stat</span><span class="p">,</span> <span class="s1">&#39;dimnames&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimnames</span><span class="p">,</span>
                     <span class="s1">&#39;dimcoords&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimcoords</span><span class="p">,</span> <span class="s1">&#39;subject&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">subject</span><span class="p">,</span>
                     <span class="s1">&#39;description&#39;</span><span class="p">:</span> <span class="n">description</span><span class="p">}</span>
        <span class="n">h5io</span><span class="o">.</span><span class="n">write_hdf5</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">)</span>

    <span class="c1"># TODO - consider weighting contribution by stat value</span>
    <span class="c1">#      - consider contributions along two dimensions</span>
    <span class="k">def</span> <span class="nf">get_contribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">along</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get mass percentage contribution to given clusters along specified</span>
<span class="sd">        dimension.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster_idx : int | array of int, optional</span>
<span class="sd">            Indices of clusters to get contribution of. Default is to calculate</span>
<span class="sd">            contribution for all clusters.</span>
<span class="sd">        along : int | str, optional</span>
<span class="sd">            Dimension along which the clusters contribution should be</span>
<span class="sd">            calculated. Default is to calculate along the first dimension.</span>
<span class="sd">        norm : bool, optional</span>
<span class="sd">            Whether to normalize contributions. Defaults to `True`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        contrib : array</span>
<span class="sd">            One-dimensional array containing float values (percentage</span>
<span class="sd">            contributions) if `norm=True` or integer values (number of</span>
<span class="sd">            elements) if `norm=False`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">cluster_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cluster_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="n">along</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">along</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">along</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">_check_dimname_arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">along</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster_idx</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">alldims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">alldims</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">alldims</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">contrib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">alldims</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
                <span class="n">contrib</span> <span class="o">=</span> <span class="n">contrib</span> <span class="o">/</span> <span class="n">contrib</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alldims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stat</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
            <span class="n">alldims</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">contrib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">alldims</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
                <span class="n">contrib</span> <span class="o">=</span> <span class="n">contrib</span> <span class="o">/</span> <span class="n">contrib</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">contrib</span>

    <span class="c1"># TODO: consider continuous vs discontinuous limits</span>
    <span class="k">def</span> <span class="nf">get_cluster_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_idx</span><span class="p">,</span> <span class="n">retain_mass</span><span class="o">=</span><span class="mf">0.65</span><span class="p">,</span>
                           <span class="n">ignore_space</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">check_dims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Find cluster limits based on percentage of cluster mass contribution</span>
<span class="sd">        to given dimensions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster_idx : int</span>
<span class="sd">            Cluster index to find limits of.</span>
<span class="sd">        retain_mass : float</span>
<span class="sd">            Percentage of cluster mass to retain in cluster limits for</span>
<span class="sd">            dimensions not specified with keyword arugments (see `kwargs`).</span>
<span class="sd">            Defaults to 0.65.</span>
<span class="sd">        ignore_space : bool</span>
<span class="sd">            Whether to ignore the spatial dimension - not look for limits along</span>
<span class="sd">            that dimension. Defaults to True.</span>
<span class="sd">        check_dims : list-like of int | None, optional</span>
<span class="sd">            Which dimensions to check. Defaults to None which checks all</span>
<span class="sd">            dimensions (with the exception of spatial if `ignore_space=True`).</span>
<span class="sd">        kwargs : additional keyword arguments</span>
<span class="sd">            Additional arguments the cluster mass to retain along specified</span>
<span class="sd">            dimensions. Float argument between 0. and 1. - defines range that</span>
<span class="sd">            is dependent on cluster mass. For example `time=0.75` defines time</span>
<span class="sd">            range limits that retain at least 75% of the cluster (calculated</span>
<span class="sd">            along given dimension - in this case time). If no kwarg is passed for</span>
<span class="sd">            given dimension then the default value of 0.65 is used - so that</span>
<span class="sd">            cluster limits are defined to retain at least 65% of the relevant</span>
<span class="sd">            cluster mass.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        limits : tuple of slices</span>
<span class="sd">            Found cluster limits expressed as a slice for each dimension,</span>
<span class="sd">            grouped together in a tuple. If `ignore_space=False` the spatial</span>
<span class="sd">            dimension is returned as a numpy array of indices. Can be used in</span>
<span class="sd">            indexing stat (`clst.stat[limits]`) or original data for example.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># TODO: add safety checks</span>
        <span class="n">has_space</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimnames</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">dimnames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;vert&#39;</span><span class="p">,</span> <span class="s1">&#39;chan&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">check_dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stat</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">has_space</span> <span class="ow">and</span> <span class="n">ignore_space</span> <span class="ow">and</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">check_dims</span><span class="p">:</span>
            <span class="n">check_dims</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">limits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stat</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">check_dims</span><span class="p">:</span>
                <span class="n">dimname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimnames</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">mass</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">dimname</span><span class="p">]</span> <span class="k">if</span> <span class="n">dimname</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="n">retain_mass</span>
                <span class="n">contrib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_contribution</span><span class="p">(</span><span class="n">cluster_idx</span><span class="p">,</span> <span class="n">along</span><span class="o">=</span><span class="n">dimname</span><span class="p">)</span>

                <span class="c1"># curent method - start at max and extend</span>
                <span class="n">adj</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">has_space</span><span class="p">)</span>
                <span class="n">limits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_get_mass_range</span><span class="p">(</span><span class="n">contrib</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="n">adj</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">limits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">limits</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">retain_mass</span><span class="o">=</span><span class="mf">0.65</span><span class="p">,</span> <span class="n">ignore_space</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get indices (tuple of slices) selecting a specified range of data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster_idx : int | None, optional</span>
<span class="sd">            Cluster index to use when calculating index. Dimensions that are</span>
<span class="sd">            not adressed using range keyword arguments will be sliced by</span>
<span class="sd">            maximizing cluster mass along that dimnensions with mass to retain</span>
<span class="sd">            given either in relevant keyword argument or if not such keyword</span>
<span class="sd">            argument `retain_mass` value is used. See `kwargs`.</span>
<span class="sd">        retain_mass : float, optional</span>
<span class="sd">            If cluster_idx is passed then dimensions not adressed using keyword</span>
<span class="sd">            arguments will be sliced to maximize given cluster&#39;s retained mass.</span>
<span class="sd">            The default value is 0.65. See `kwargs`.</span>
<span class="sd">        kwargs : additional arguments</span>
<span class="sd">            Additional arguments used in aggregation, defining the range to</span>
<span class="sd">            aggregate for given dimension. List of two values defines explicit</span>
<span class="sd">            range: for example keyword argument `freq=[6, 8]` aggregates the</span>
<span class="sd">            6 - 8 Hz range. Float argument between 0. and 1. defines range that</span>
<span class="sd">            is dependent on cluster mass. For example `time=0.75` defines time</span>
<span class="sd">            range that retains at least 75% of the cluster (calculated along</span>
<span class="sd">            the aggregated dimension - in this case time). If no kwarg is</span>
<span class="sd">            passed for given dimension then the default value is 0.65 so that</span>
<span class="sd">            range is defined to retain at least 65% of the cluster mass.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        idx : tuple of slices</span>
<span class="sd">            Tuple of slices selecting the requested range of the data. Can be</span>
<span class="sd">            used in indexing stat (`clst.stat[idx]`) or clusters (</span>
<span class="sd">            `clst.clusters[:, *idx]`) for example.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">normal_indexing</span><span class="p">,</span> <span class="n">mass_indexing</span> <span class="o">=</span> <span class="n">_check_dimnames_kwargs</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">check_dimcoords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">split_range_mass</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">normal_indexing</span><span class="p">,</span> <span class="n">mass_indexing</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">_index_from_dim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimnames</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimcoords</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">normal_indexing</span><span class="p">)</span>

        <span class="c1"># TODO - when retain mass is specified</span>
        <span class="k">if</span> <span class="n">cluster_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                          <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span>
            <span class="c1"># check cluster limits only if some dim limits were not specified</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">check_dims</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">idx_mass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cluster_limits</span><span class="p">(</span>
                    <span class="n">cluster_idx</span><span class="p">,</span> <span class="n">ignore_space</span><span class="o">=</span><span class="n">ignore_space</span><span class="p">,</span>
                    <span class="n">retain_mass</span><span class="o">=</span><span class="n">retain_mass</span><span class="p">,</span> <span class="o">**</span><span class="n">mass_indexing</span><span class="p">)</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">idx_mass</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">check_dims</span> <span class="k">else</span> <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">))])</span>
        <span class="k">return</span> <span class="n">idx</span>

    <span class="c1"># maybe rename to `plot mass`?</span>
    <span class="k">def</span> <span class="nf">plot_contribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimname</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Plot contribution of clusters along specified dimension.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dimension : str | int</span>
<span class="sd">            Dimension along which to calculate contribution.</span>
<span class="sd">        picks : list-like | None, optional</span>
<span class="sd">            Cluster indices whose contributions should be shown.</span>
<span class="sd">        axis : matplotlib Axes | None, optional</span>
<span class="sd">            Matplotlib axis to plot in.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        axis : matplotlib Axes</span>
<span class="sd">            Axes with the plot.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">return</span> <span class="n">plot_cluster_contribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimname</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">aggregate</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">set_light</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Plot cluster.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        clst : Clusters</span>
<span class="sd">            Clusters object to use in plotting.</span>
<span class="sd">        cluster_idx : int</span>
<span class="sd">            Cluster index to plot.</span>
<span class="sd">        aggregate : str</span>
<span class="sd">            TODO: mean, max, weighted</span>
<span class="sd">        vmin : float, optional</span>
<span class="sd">            Value mapped to minimum in the colormap. Inferred from data by default.</span>
<span class="sd">        vmax : float, optional</span>
<span class="sd">            Value mapped to maximum in the colormap. Inferred from data by default.</span>
<span class="sd">        title : str, optional</span>
<span class="sd">            Optional title for the figure.</span>
<span class="sd">        **kwargs : additional keyword arguments</span>
<span class="sd">            Additional arguments used in aggregation, defining the range to</span>
<span class="sd">            aggregate for given dimension. List of two values defines explicit</span>
<span class="sd">            range: for example keyword argument `freq=[6, 8]` aggregates the</span>
<span class="sd">            6 - 8 Hz range. Float argument between 0. and 1. defines range that is</span>
<span class="sd">            dependent on cluster mass. For example `time=0.75` defines time range</span>
<span class="sd">            that retains at least 75% of the cluster (calculated along the</span>
<span class="sd">            aggregated dimension - in this case time). If no kwarg is passed for</span>
<span class="sd">            given dimension then the default value is 0.65 so that range is</span>
<span class="sd">            defined to retain at least 65% of the cluster mass.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        topo : borsar.viz.Topo class | pysurfer.Brain</span>
<span class="sd">            Figure object used in plotting - borsar.viz.Topo for channel-level</span>
<span class="sd">            plotting and pysurfer.Brain for plots on brain surface.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt; # to plot the first cluster within 8 - 10 Hz</span>
<span class="sd">        &gt; clst.plot(cluster_idx=0, freq=[8, 10])</span>
<span class="sd">        &gt; # to plot the second cluster selecting frequencies that make up at least</span>
<span class="sd">        &gt; # 70% of the cluster mass:</span>
<span class="sd">        &gt; clst.plot(cluster_idx=1, freq=0.7)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimnames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;To plot the data you need to construct the &#39;</span>
                             <span class="s1">&#39;cluster using the dimnames keyword argument.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimnames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;vert&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">plot_cluster_src</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_idx</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span>
                                    <span class="n">aggregate</span><span class="o">=</span><span class="n">aggregate</span><span class="p">,</span> <span class="n">set_light</span><span class="o">=</span><span class="n">set_light</span><span class="p">,</span>
                                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimnames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;chan&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">plot_cluster_chan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_idx</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">aggregate</span><span class="o">=</span><span class="n">aggregate</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="c1"># TODO - add special case for dimension=&#39;vert&#39; and &#39;chan&#39;</span>
<span class="k">def</span> <span class="nf">plot_cluster_contribution</span><span class="p">(</span><span class="n">clst</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Plot contribution of clusters along specified dimension.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dimension : str | int</span>
<span class="sd">        Dimension along which to calculate contribution.</span>
<span class="sd">    picks : list-like | None, optional</span>
<span class="sd">        Cluster indices whose contributions should be shown.</span>
<span class="sd">    axis : matplotlib Axes | None, optional</span>
<span class="sd">        Matplotlib axis to plot in.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    axis : matplotlib Axes</span>
<span class="sd">        Axes with the plot.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

    <span class="c1"># check dimname and return index</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">_check_dimname_arg</span><span class="p">(</span><span class="n">clst</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>

    <span class="c1"># check if any clusters</span>
    <span class="n">n_clusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">clst</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_clusters</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No clusters present in Clusters object.&#39;</span><span class="p">)</span>

    <span class="n">picks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">))</span> <span class="k">if</span> <span class="n">picks</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">picks</span>

    <span class="c1"># create freq coords and label</span>
    <span class="k">if</span> <span class="n">clst</span><span class="o">.</span><span class="n">dimcoords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dimcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">clst</span><span class="o">.</span><span class="n">stat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">dimlabel</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> bins&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_get_full_dimname</span><span class="p">(</span><span class="n">dimension</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dimcoords</span> <span class="o">=</span> <span class="n">clst</span><span class="o">.</span><span class="n">dimcoords</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">dimlabel</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_get_full_dimname</span><span class="p">(</span><span class="n">dimension</span><span class="p">),</span>
                                    <span class="n">_get_units</span><span class="p">(</span><span class="n">dimension</span><span class="p">))</span>

    <span class="c1"># make sure we have an axes to plot to</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span>

    <span class="c1"># plot cluster contribution</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">:</span>
        <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;idx=</span><span class="si">{}</span><span class="s1">, p=</span><span class="si">{:.3f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">clst</span><span class="o">.</span><span class="n">pvals</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">contrib</span> <span class="o">=</span> <span class="n">clst</span><span class="o">.</span><span class="n">get_contribution</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">along</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dimcoords</span><span class="p">,</span> <span class="n">contrib</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

    <span class="n">axis</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">)</span>
    <span class="n">axis</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">dimlabel</span><span class="p">)</span>

    <span class="c1"># TODO - reduced dimnames could be: channel-frequency bins</span>
    <span class="n">elements_name</span> <span class="o">=</span> <span class="p">({</span><span class="s1">&#39;vert&#39;</span><span class="p">:</span> <span class="s1">&#39;vertices&#39;</span><span class="p">,</span> <span class="s1">&#39;chan&#39;</span><span class="p">:</span> <span class="s1">&#39;channels&#39;</span><span class="p">}</span>
                      <span class="p">[</span><span class="n">clst</span><span class="o">.</span><span class="n">dimnames</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">if</span> <span class="n">clst</span><span class="o">.</span><span class="n">dimcoords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                     <span class="k">else</span> <span class="s1">&#39;elements&#39;</span><span class="p">)</span>
    <span class="n">axis</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Number of &#39;</span> <span class="o">+</span> <span class="n">elements_name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">axis</span>


<span class="k">def</span> <span class="nf">plot_cluster_chan</span><span class="p">(</span><span class="n">clst</span><span class="p">,</span> <span class="n">cluster_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">aggregate</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Plot cluster in source space.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    clst : Clusters</span>
<span class="sd">        Clusters object to use in plotting.</span>
<span class="sd">    cluster_idx : int</span>
<span class="sd">        Cluster index to plot.</span>
<span class="sd">    aggregate : str</span>
<span class="sd">        TODO: mean, max, weighted</span>
<span class="sd">    vmin : float, optional</span>
<span class="sd">        Value mapped to minimum in the colormap. Inferred from data by default.</span>
<span class="sd">    vmax : float, optional</span>
<span class="sd">        Value mapped to maximum in the colormap. Inferred from data by default.</span>
<span class="sd">    title : str, optional</span>
<span class="sd">        Optional title for the figure.</span>
<span class="sd">    **kwargs : additional keyword arguments</span>
<span class="sd">        Additional arguments used in aggregation, defining the range to</span>
<span class="sd">        aggregate for given dimension. List of two values defines explicit</span>
<span class="sd">        range: for example keyword argument `freq=[6, 8]` aggregates the</span>
<span class="sd">        6 - 8 Hz range. Float argument between 0. and 1. defines range that is</span>
<span class="sd">        dependent on cluster mass. For example `time=0.75` defines time range</span>
<span class="sd">        that retains at least 75% of the cluster (calculated along the</span>
<span class="sd">        aggregated dimension - in this case time). If no kwarg is passed for</span>
<span class="sd">        given dimension then the default value is 0.65 so that range is</span>
<span class="sd">        defined to retain at least 65% of the cluster mass.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    topo : borsar.viz.Topo class</span>
<span class="sd">        Figure object used in plotting.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt; # to plot the first cluster within 8 - 10 Hz</span>
<span class="sd">    &gt; clst.plot(cluster_idx=0, freq=[8, 10])</span>
<span class="sd">    &gt; # to plot the second cluster selecting frequencies that make up at least</span>
<span class="sd">    &gt; # 70% of the cluster mass:</span>
<span class="sd">    &gt; clst.plot(cluster_idx=1, freq=0.7)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># TODO - if cluster_idx is not None and there is no such cluster - error</span>
    <span class="c1">#      - if no clusters and None - plot without highlighting</span>
    <span class="n">cluster_idx</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">cluster_idx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">cluster_idx</span>

    <span class="c1"># split kwargs into topo_kwargs and dim_kwargs</span>
    <span class="n">topo_kwargs</span><span class="p">,</span> <span class="n">dim_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(),</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">clst</span><span class="o">.</span><span class="n">dimnames</span><span class="p">:</span>
            <span class="n">topo_kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dim_kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="c1"># TODO - aggregate should work when no clusters</span>
    <span class="c1"># get and aggregate cluster mask and cluster stat</span>
    <span class="n">clst_mask</span><span class="p">,</span> <span class="n">clst_stat</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">_aggregate_cluster</span><span class="p">(</span>
        <span class="n">clst</span><span class="p">,</span> <span class="n">cluster_idx</span><span class="p">,</span> <span class="n">mask_proportion</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">retain_mass</span><span class="o">=</span><span class="mf">0.65</span><span class="p">,</span>
        <span class="n">ignore_space</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">dim_kwargs</span><span class="p">)</span>

    <span class="c1"># create pysurfer brain</span>
    <span class="kn">from</span> <span class="nn">borsar.viz</span> <span class="k">import</span> <span class="n">Topo</span>
    <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">_get_clim</span><span class="p">(</span><span class="n">clst_stat</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span> <span class="n">pysurfer</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">topo</span> <span class="o">=</span> <span class="n">Topo</span><span class="p">(</span><span class="n">clst_stat</span><span class="p">,</span> <span class="n">clst</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="o">**</span><span class="n">topo_kwargs</span><span class="p">)</span>
    <span class="n">topo</span><span class="o">.</span><span class="n">solid_lines</span><span class="p">()</span>

    <span class="c1"># FIXME: temporary hack to make all channels more visible</span>
    <span class="n">topo</span><span class="o">.</span><span class="n">mark_channels</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clst_stat</span><span class="p">)),</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                       <span class="n">markerfacecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clst</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">cluster_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">topo</span><span class="o">.</span><span class="n">mark_channels</span><span class="p">(</span><span class="n">clst_mask</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">topo</span>


<span class="c1"># - [ ] add special functions for handling dims like vert or chan</span>
<span class="k">def</span> <span class="nf">_index_from_dim</span><span class="p">(</span><span class="n">dimnames</span><span class="p">,</span> <span class="n">dimcoords</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find axis slices given dimnames, dimaxes and dimname keyword arguments</span>
<span class="sd">    with list of `[start, end]` each.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dimnames : list of str</span>
<span class="sd">        List of dimension names. For example `[&#39;chan&#39;, &#39;freq&#39;]` or `[&#39;vert&#39;,</span>
<span class="sd">        &#39;time&#39;]`. The length of `dimnames` has to mach `stat.ndim`.</span>
<span class="sd">    dimcoords : list of arrays</span>
<span class="sd">        List of arrays, where each array contains coordinates (labels) for</span>
<span class="sd">        consecutive elements in corresponding dimension.</span>
<span class="sd">    **kwargs : additional keywords</span>
<span class="sd">        Keywords referring to dimension names and values each being a list of two</span>
<span class="sd">        values representing lower and upper limits of dimension selection.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    idx : tuple of slices</span>
<span class="sd">        Tuple that can be used to index the data array: `data[idx]`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; dimnames = [&#39;freq&#39;, &#39;time&#39;]</span>
<span class="sd">    &gt;&gt;&gt; dimcoords = [np.arange(8, 12), np.arange(-0.2, 0.6, step=0.05)]</span>
<span class="sd">    &gt;&gt;&gt; _index_from_dim(dimnames, dimcoords, freq=[9, 11], time=[0.25, 0.5])</span>
<span class="sd">    (slice(1, 4, None), slice(9, 15, None))</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">dname</span><span class="p">,</span> <span class="n">dcoord</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dimnames</span><span class="p">,</span> <span class="n">dimcoords</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
            <span class="k">continue</span>
        <span class="n">sel_ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">dname</span><span class="p">)</span>
        <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">find_range</span><span class="p">(</span><span class="n">dcoord</span><span class="p">,</span> <span class="n">sel_ax</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>


<span class="c1"># CHECKS</span>
<span class="c1"># ------</span>
<span class="k">def</span> <span class="nf">_clusters_safety_checks</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="n">pvals</span><span class="p">,</span> <span class="n">stat</span><span class="p">,</span> <span class="n">dimnames</span><span class="p">,</span> <span class="n">dimcoords</span><span class="p">,</span>
                            <span class="n">description</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Perform basic type and safety checks for Clusters.&#39;&#39;&#39;</span>
    <span class="c1"># check clusters when it is a list</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">n_clusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_clusters</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cluster_shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">clst</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">clst</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">]</span>
            <span class="n">all_shapes_equal</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">clst_shp</span> <span class="o">==</span> <span class="n">cluster_shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                    <span class="k">for</span> <span class="n">clst_shp</span> <span class="ow">in</span> <span class="n">cluster_shapes</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">all_shapes_equal</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All clusters have to be of the same &#39;</span>
                                 <span class="s1">&#39;shape.&#39;</span><span class="p">)</span>
            <span class="n">all_arrays_bool</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">clst</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;bool&#39;</span> <span class="k">for</span> <span class="n">clst</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">all_arrays_bool</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;All clusters have to be boolean arrays.&#39;</span><span class="p">)</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># check stat</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`stat` must be a numpy array.&#39;</span><span class="p">)</span>

    <span class="c1"># check clusters shape along stat shape</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">n_clusters</span> <span class="o">=</span> <span class="n">clusters</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">n_clusters</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">stat</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">clusters</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Every cluster has to have the same shape as &#39;</span>
                                 <span class="s1">&#39;stat.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">clusters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`clusters` has to be either a list of arrays or one &#39;</span>
                        <span class="s1">&#39;array with the first dimension corresponding to &#39;</span>
                        <span class="s1">&#39;clusters or None if no clusters were found.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">clusters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># TODO: maybe warn if no clusters but pvals is not None/empty</span>
        <span class="n">pvals</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pvals</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`pvals` has to be a list of floats or numpy array.&#39;</span><span class="p">)</span>
        <span class="c1"># check if each element of list is float and array is of dtype float</span>

    <span class="k">if</span> <span class="n">dimnames</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimnames</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`dimnames` must be a list of dimension names.&#39;</span>
                             <span class="s1">&#39;Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dimnames</span><span class="p">)))</span>
        <span class="n">which_str</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">dimnames</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">which_str</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">other_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">dimnames</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">which_str</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`dimnames` must be a list of strings, but some &#39;</span>
                            <span class="s1">&#39;of the elements in the list you passed are not &#39;</span>
                            <span class="s1">&#39;strings, for example: </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">other_type</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimnames</span><span class="p">)</span> <span class="o">==</span> <span class="n">stat</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Length of `dimnames` must be the same as number&#39;</span>
                             <span class="s1">&#39; of dimensions in `stat`.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;chan&#39;</span> <span class="ow">in</span> <span class="n">dimnames</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dimnames</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;chan&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span>
            <span class="s1">&#39;vert&#39;</span> <span class="ow">in</span> <span class="n">dimnames</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dimnames</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;vert&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;If using channels (&quot;chan&quot; dimension name) or vertices (&#39;</span>
                   <span class="s1">&#39;for source space - &quot;vert&quot; dimension name) - it must be &#39;</span>
                   <span class="s1">&#39;the first dimension in the `stat` array and therefore the&#39;</span>
                   <span class="s1">&#39; first dimension name in `dimnames`.&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dimcoords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimcoords</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`dimcoords` must be a list of dimension &#39;</span>
                             <span class="s1">&#39;coordinates. Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dimcoords</span><span class="p">)))</span>

        <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dimcoords</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">dimnames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;chan&#39;</span><span class="p">,</span> <span class="s1">&#39;vert&#39;</span><span class="p">]:</span>
            <span class="n">dims</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">equal_len</span> <span class="o">=</span> <span class="p">[</span><span class="n">stat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimcoords</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">equal_len</span><span class="p">):</span>
            <span class="n">nonequal_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">equal_len</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;The length of each dimension coordinate (except for the &#39;</span>
                   <span class="s1">&#39;spatial dimension - channels or vertices) has to be the &#39;</span>
                   <span class="s1">&#39;same as the length of the corresponding dimension in &#39;</span>
                   <span class="s1">&#39;`stat` array.&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">_check_description</span><span class="p">(</span><span class="n">description</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">pvals</span>


<span class="k">def</span> <span class="nf">_check_description</span><span class="p">(</span><span class="n">description</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Validate if description is of correct type.&#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">description</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">description</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Description has to be either a string or a dict&#39;</span>
                            <span class="s1">&#39;ionary, got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">description</span><span class="p">)))</span>


<span class="k">def</span> <span class="nf">_clusters_chan_vert_checks</span><span class="p">(</span><span class="n">dimnames</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">subject</span><span class="p">,</span> <span class="n">subjects_dir</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Safety checks for Clusters spatial dimension.&#39;&#39;&#39;</span>
    <span class="kn">import</span> <span class="nn">mne</span>
    <span class="k">if</span> <span class="n">dimnames</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s1">&#39;chan&#39;</span> <span class="ow">in</span> <span class="n">dimnames</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">info</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">mne</span><span class="o">.</span><span class="n">Info</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;You must pass an `mne.Info` in order to use &#39;</span>
                            <span class="s1">&#39;&quot;chan&quot; dimension. Use `info` keyword argument.&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">dimnames</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s1">&#39;vert&#39;</span> <span class="ow">in</span> <span class="n">dimnames</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">src</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">mne</span><span class="o">.</span><span class="n">SourceSpaces</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;You must pass an `mne.SourceSpaces` in order to &#39;</span>
                            <span class="s1">&#39;use &quot;vert&quot; dimension. Use `src` keyword&#39;</span>
                            <span class="s1">&#39; argument.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">subject</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subject</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;You must pass a subject string in order to &#39;</span>
                            <span class="s1">&#39;use &quot;vert&quot; dimension. Use `subject` keyword&#39;</span>
                            <span class="s1">&#39; argument.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">subjects_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subjects_dir</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">get_subjects_dir</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">subjects_dir</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subjects_dir</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;You must pass a `subjects_dir` freesurfer folder&#39;</span>
                            <span class="s1">&#39; name in order to use &quot;vert&quot; dimension. Use &#39;</span>
                            <span class="s1">&#39;`subjects_dir` keyword argument.&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_dimname_arg</span><span class="p">(</span><span class="n">clst</span><span class="p">,</span> <span class="n">dimname</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Check dimension name and find its index.&#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimname</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Dimension argument has to be string (dimension name) &#39;</span>
                        <span class="s1">&#39;or int (dimension index).&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimname</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">clst</span><span class="o">.</span><span class="n">dimnames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Clusters has to have `dimnames` attribute to use &#39;</span>
                            <span class="s1">&#39;operations on named dimensions.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dimname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">clst</span><span class="o">.</span><span class="n">dimnames</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Clusters does not seem to have the dimension you&#39;</span>
                            <span class="s1">&#39; requested. You asked for &quot;</span><span class="si">{}</span><span class="s1">&quot;, while Clusters has &#39;</span>
                            <span class="s1">&#39;the following dimensions: </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">dimname</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">clst</span><span class="o">.</span><span class="n">dimnames</span><span class="p">)))</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">clst</span><span class="o">.</span><span class="n">dimnames</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dimname</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">dimname</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dimname</span> <span class="o">&lt;</span> <span class="n">clst</span><span class="o">.</span><span class="n">stat</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Dimension, if integer, must be greater or equal &#39;</span>
                             <span class="s1">&#39;to 0 and lower than number of dimensions of the &#39;</span>
                             <span class="s1">&#39;statistical map. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dimname</span><span class="p">))</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">dimname</span>
    <span class="k">return</span> <span class="n">idx</span>


<span class="k">def</span> <span class="nf">_check_dimnames_kwargs</span><span class="p">(</span><span class="n">clst</span><span class="p">,</span> <span class="n">check_dimcoords</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">split_range_mass</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Ensure that **kwargs are correct dimnames and dimcoords.&#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">clst</span><span class="o">.</span><span class="n">dimnames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Clusters has to have dimnames to use operations &#39;</span>
                        <span class="s1">&#39;on named dimensions.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">check_dimcoords</span> <span class="ow">and</span> <span class="n">clst</span><span class="o">.</span><span class="n">dimcoords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Clusters has to have dimcoords to use operations &#39;</span>
                        <span class="s1">&#39;on named dimensions.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">split_range_mass</span><span class="p">:</span>
        <span class="n">normal_indexing</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">mass_indexing</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">clst</span><span class="o">.</span><span class="n">dimnames</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Could not find requested dimension </span><span class="si">{}</span><span class="s1">. Available &#39;</span>
                   <span class="s1">&#39;dimensions: </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">clst</span><span class="o">.</span><span class="n">dimnames</span><span class="p">)))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">split_range_mass</span><span class="p">:</span>
            <span class="n">dval</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="c1"># TODO - more elaborate checks</span>
            <span class="n">dim_type</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;range&#39;</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dval</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;mass&#39;</span> <span class="k">if</span>
                        <span class="nb">isinstance</span><span class="p">(</span><span class="n">dval</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dim_type</span> <span class="o">==</span> <span class="s1">&#39;mass&#39;</span><span class="p">:</span>
                <span class="n">mass_indexing</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">dval</span>
                <span class="n">normal_indexing</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">dim_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The values used in dimension name indexing &#39;</span>
                                <span class="s1">&#39;have to be either ranges (list of two &#39;</span>
                                <span class="s1">&#39;values) or cluster mass to retain (float),&#39;</span>
                                <span class="s1">&#39; got </span><span class="si">{}</span><span class="s1"> for dimension </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dval</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">split_range_mass</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">normal_indexing</span><span class="p">,</span> <span class="n">mass_indexing</span>


<span class="c1"># UTILS</span>
<span class="c1"># -----</span>
<span class="k">def</span> <span class="nf">_get_full_dimname</span><span class="p">(</span><span class="n">dimname</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Return full dimension name.&#39;&#39;&#39;</span>
    <span class="n">dct</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;freq&#39;</span><span class="p">:</span> <span class="s1">&#39;frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;vert&#39;</span><span class="p">:</span> <span class="s1">&#39;vertices&#39;</span><span class="p">,</span>
           <span class="s1">&#39;chan&#39;</span><span class="p">:</span> <span class="s1">&#39;channels&#39;</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">dct</span><span class="p">[</span><span class="n">dimname</span><span class="p">]</span> <span class="k">if</span> <span class="n">dimname</span> <span class="ow">in</span> <span class="n">dct</span> <span class="k">else</span> <span class="n">dimname</span>


<span class="k">def</span> <span class="nf">_get_mass_range</span><span class="p">(</span><span class="n">contrib</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Find range that retains given mass (sum) of the contributions vector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    contrib : np.ndarray</span>
<span class="sd">        Vector of contributions.</span>
<span class="sd">    mass : float</span>
<span class="sd">        Requested mass to retain.</span>
<span class="sd">    adjacent : boolean</span>
<span class="sd">        Whether to extend from the maximum point by adjacency or not.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    extent : slice or np.ndarray of int</span>
<span class="sd">        Slice (when `adjacency=True`) or indices (when `adjacency=False`)</span>
<span class="sd">        retaining the required mass.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">contrib_len</span> <span class="o">=</span> <span class="n">contrib</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">max_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">contrib</span><span class="p">)</span>
    <span class="n">current_mass</span> <span class="o">=</span> <span class="n">contrib</span><span class="p">[</span><span class="n">max_idx</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">adjacent</span><span class="p">:</span>
        <span class="n">side_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">max_idx</span><span class="p">,</span> <span class="n">max_idx</span><span class="p">])</span>
        <span class="k">while</span> <span class="n">current_mass</span> <span class="o">&lt;</span> <span class="n">mass</span><span class="p">:</span>
            <span class="n">side_idx</span> <span class="o">+=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span> <span class="k">if</span> <span class="n">side_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">contrib</span><span class="p">[</span><span class="n">side_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="mf">0.</span> <span class="k">if</span> <span class="n">side_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">contrib</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span> <span class="n">contrib</span><span class="p">[</span><span class="n">side_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>

            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="n">side_idx</span> <span class="o">+=</span> <span class="p">[</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">break</span>
            <span class="nb">ord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
            <span class="n">current_mass</span> <span class="o">+=</span> <span class="n">contrib</span><span class="p">[</span><span class="n">side_idx</span><span class="p">[</span><span class="nb">ord</span><span class="p">]]</span>
            <span class="n">one_back</span> <span class="o">=</span> <span class="p">[</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">one_back</span><span class="p">[</span><span class="nb">ord</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">side_idx</span> <span class="o">+=</span> <span class="n">one_back</span>

        <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">side_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">side_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">contrib</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">cum_mass</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">contrib</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
        <span class="n">retains_mass</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cum_mass</span> <span class="o">&gt;=</span> <span class="n">mass</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">retains_mass</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[:</span><span class="n">retains_mass</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>



<span class="k">def</span> <span class="nf">_cluster_selection</span><span class="p">(</span><span class="n">clst</span><span class="p">,</span> <span class="n">sel</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Select Clusters according to selection vector `sel`&#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">sel</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">clst</span>
    <span class="k">if</span> <span class="n">sel</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;bool&#39;</span><span class="p">:</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sel</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">clst</span><span class="o">.</span><span class="n">cluster_polarity</span> <span class="o">=</span> <span class="p">[</span><span class="n">clst</span><span class="o">.</span><span class="n">cluster_polarity</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                                 <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">sel</span><span class="p">]</span>
        <span class="n">clst</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">clst</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">sel</span><span class="p">]</span>
        <span class="n">clst</span><span class="o">.</span><span class="n">pvals</span> <span class="o">=</span> <span class="n">clst</span><span class="o">.</span><span class="n">pvals</span><span class="p">[</span><span class="n">sel</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">clst</span><span class="o">.</span><span class="n">cluster_polarity</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">clst</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">clst</span><span class="o">.</span><span class="n">pvals</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">clst</span>


<span class="k">def</span> <span class="nf">_ensure_correct_info</span><span class="p">(</span><span class="n">clst</span><span class="p">):</span>
    <span class="c1"># check if we have channel names:</span>
    <span class="n">has_ch_names</span> <span class="o">=</span> <span class="n">clst</span><span class="o">.</span><span class="n">dimcoords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">has_ch_names</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">mne</span> <span class="k">import</span> <span class="n">pick_info</span>
        <span class="kn">from</span> <span class="nn">borsar.channels</span> <span class="k">import</span> <span class="n">find_channels</span>

        <span class="n">ch_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;-&#39;</span> <span class="ow">in</span> <span class="n">ch</span> <span class="k">else</span> <span class="n">ch</span>
                    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">clst</span><span class="o">.</span><span class="n">dimcoords</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">ch_idx</span> <span class="o">=</span> <span class="n">find_channels</span><span class="p">(</span><span class="n">clst</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">)</span>
        <span class="n">clst</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">pick_info</span><span class="p">(</span><span class="n">clst</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">ch_idx</span><span class="p">)</span>
</pre></div>

</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2018, Mikołaj Magnuski.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>